[
  
  {
    "title": "Bárcsak tudnék rendezni (egy valszámos feladat)",
    "url": "/posts/2022-04-12-barcsak-tudnek-rendezni/",
    "categories": "codeforces, valszam",
    "tags": "codeforces, valszam, varhato-ertek, markov-lanc",
    "date": "2022-04-12 13:00:00 +0200",
    





    
    "snippet": "#Ebben a cikkben szeretnék egy kicsit bővebben a Codeforces 1753C: Wish I Knew How to Sort feladat megoldásairól beszélni.A feladatban kapunk egy bináris, $n$ elemű $a$ tömböt, amit rendezni szeret...",
    "content": "#Ebben a cikkben szeretnék egy kicsit bővebben a Codeforces 1753C: Wish I Knew How to Sort feladat megoldásairól beszélni.A feladatban kapunk egy bináris, $n$ elemű $a$ tömböt, amit rendezni szeretnénk, de sajnos az algel tanárunk elfelejtette megtanítani nekünk a rendezési algoritmusokat. :) Jobb ötlet híján egy randomizált módszert választunk, melyben egy lépés a következőképpen néz ki:  Véletlenszerűen (egyenletes eloszlással, egymástól és a korábbi lépéseinktől függetlenül) rámutatunk két pozícióra a tömbben. Legyenek ezek $i$ és $j$ indexszel jelölve, ahol $i &lt; j$.  Ha rossz sorrendben vannak ($a_i &gt; a_j$), megcseréljük őket, egyébként nem csinálunk semmit.Ezt a lépést addig ismételjük, amíg a tömb rendezett nem lesz.Kérdés: Mi a várható értéke a végrehajtott lépéseknek?A feladatban technikai részlet, hogy a megoldást irreducibilis (tovább már nem egyszerűsíthető alakú) törtként kell kiírni, ennek a módszerére a végén térek ki.A feladatnak legalább kettő, egymástól nagyon különböző megoldása van, mindkettőt nagyon hasznos ismerni valszámos feladatok kezeléséhez.MegfigyelésAz első dolog, amit a feladat kapcsán észreveszünk, hogy tudjuk hány darab $0$-ás és $1$-es található az $a$ tömbben, ami alapján be tudunk húzni egy elválasztó vonalat, ami majd a végeredményben a $0$-ák és $1$-esek határa lesz.Ezután a véletlenül választott $i &lt; j$ pár elhelyezkedése szerint tulajdonképpen két különböző eset van:  $i$ az elválasztó vonal előtt, $j$ utána van.  Mindkettő az elválasztó vonal előtt / után van.Az 1. esetben ha történik csere azzal hasznos munkát végeztünk, hiszen növeltük a $0$-ák számát a vonal előtt és az $1$-esek számát a vonal után, ezzel közelebb kerültünk a célállapothoz.A 2. esetben ha történik csere azzal nem végeztünk hasznos munkát, hiszen pusztán határokon belül mozgattunk dolgokat, továbbra is ugyanannyi $1$-est kell még a határ bal oldaláról a jobb oldalára mozgatni, miközben a helyükre $0$-ákat hozunk.Tehát elmondható, hogy a feladat szempontjából lényegtelen a $0$-ák és $1$-esek pontos elhelyezkedése, csak az számít, hogy hány darab található belőlük a határvonal egy-egy oldalán. Hasznos lépés csak akkor történik, amikor az $i$ a határ előtt és a $j$ a határ után van, továbbá $a_i = 1$ és $a_j = 0$. Minden más esetben a lépés nem változtat az aktuális állapoton.Első megoldási módszer: Geometriai eloszlás és várható érték linearitásaAki tanult valószínűségszámítást, az ráismerhet a feladatban egy nevezetes eloszlásra: ez a geometriai eloszlás. Ez mindig akkor kerül elő, amikor “addig ismétlünk valamit, amíg nem sikerül”.Egy kis kitérő: a geometriai eloszlásról (annak, aki még nem ismeri)Pontosabban:  Egy véletlen kísérletsorozatot hajtunk végre.  A kísérleteknek lehetséges kimenetelei közül megkülönböztetünk “sikeres” és nem “sikeres” kimeneteleket.          A kimenetelek halmazát szoktuk eseménynek hívni, tehát van egy “sikerült” és egy “nem sikerült” eseményünk.      A “sikeres” esemény valószínűsége ismert, jelölje $p$, a “nem sikeres” esemény valószínűsége ekkor $1-p$.        Az egyes kísérleteket egymástól függetlenül végezzük (azaz a sikeresség valószínűségét nem befolyásolják a korábbi kísérletek eredményei).  Akkor állunk meg, amikor sikeres eredményt kapunk.  Definiálunk egy (valószínűségi) változót, ami azt mondja meg, hogy hány lépést végeztünk.Például ha az $X$ változó jelöli a lépések számát, akkor feltehetjük azt a kérdést, hogy mennyi a valószínűsége annak, hogy pontosan $i$ darab lépést végeztünk, azaz $P(X=i) = ?$.Ehhez kellett $i-1$ darab sikertelen, majd $1$ darab sikeres kísérlet, tehát\\(P(X=i) = (1-p)^{i-1}p\\).$i$ lehetséges értékei pedig $1$ és $\\infty$ között bármilyen lépésszám.A nevezetes eloszlások ismeretének előnye például, hogy tanuljuk a várható értéküket. Ezt az $X$ változóhoz $E(X)$-el jelöljük az angol “expectation value” kifejezésből. Definíció szerint a várható értéke egy változónak a lehetséges értékeinek a valószínűségükkel súlyozott összege, azaz\\[E(X) = \\sum\\limits_{i} i \\cdot{} P(X=i).\\](Aztán lehet később arról beszélni, hogy ha mintavételezzük $X$-et sokszor, azaz végrehajtjuk a véletlen kísérletsorozatot és felírjuk hány lépést végeztünk, akkor a kapott lépésszámok átlaga egyre jobban megközelíti majd ezt az elméleti várható értéket, de ez már a statisztika világa.)A geometriai eloszlás várható értékeA geometriai eloszlás elméleti várható értéke például $\\frac{1}{p}$, ezt a fenti képletbe helyettesítéssel könnyen ki is számolhatjuk:\\[E(X) = \\sum\\limits_{i} i \\cdot{} P(X=i) = \\sum\\limits_{i} i \\cdot{} (1-p)^{i-1}p = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i-1}\\]Ilyen végtelen összegekkel már sokszor találkoztunk és sokféleképpen el lehet bánni velük. Most főleg az az $i$ szorzó zavar minket, anélkül mértani sor lenne, tehát ettől kellene megszabadulni.Például kiindulunk az eredeti egyenlőségből és nézzük meg hogy néz ez ki ha elkezdjük kifejteni:\\[E(X) = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i-1} = p + 2p(1-p) + 3p(1-p)^2 + 4p(1-p)^3 + \\cdots{}\\]Szorozzuk meg mindkét oldalt $(1-p)$-vel:\\[(1-p) E(X) = p \\sum\\limits_{i=1}^{\\infty} i \\cdot{} (1-p)^{i} = p(1-p) + 2p(1-p)^2 + 3p(1-p)^3 + 4p(1-p)^4 + \\cdots{}\\]Észrevehetjük, hogy ha kivonjuk egymásból a kettőt, akkor azzal pont az $i$-s szorzóktól szabadulunk meg és egy végtelen mértani sor összegét kapjuk:\\[E(X) - (1-p) E(X) = p + p(1-p) + p(1-p)^2 + p(1-p)^3 + p(1-p)^4 + \\cdots{} = p \\sum\\limits_{i=0}^{\\infty} (1-p)^{i} = p \\cdot{} \\frac{1}{1-(1-p)} = 1\\]Azaz\\[E(X) - E(X) + pE(X) = 1,\\]\\[pE(X) = 1,\\]\\[E(X) = \\frac{1}{p}.\\]Érdemes erre az eredményre emlékezni.Vissza a feladathozValamilyen “addig csináljuk amíg nem sikerül” érzésünk van a feladattal kapcsolatban, tehát valamilyen geometriai valószínűségi változó lesz a háttérben, aminek mostmár ismerjük a várható értékét. Próbáljuk meg valahogy így modellezni a feladatot!Hamar érezhető, hogy egyetlen változó kevés ahhoz, hogy modellezzük a problémát. Gondoljunk csak bele: ekkor a megállási feltétel az lenne, hogy “rendezetté vált” a tömb, ennek kellene egy fix $p$ valószínűséget meghatározni, ami minden lépésben ráadásul ugyanannyi kellene hogy legyen, hiszen a lépések függetlenek. Ez így nem fog működni.Helyette megtehetjük azt, hogy a lépéseket szétosztjuk több valószínűségi változó között: legyen a sikeres esemény inkább az, amikor a véletlenül választott $i$ és $j$ indexeink a határvonal két oldalára esnek és végrehajtódik egy csere. Ebből az eseményből több is lesz, vagyis több valószínűségi változóra lesz szükségünk. Azonban szerencsére már a kiindulási $a$ tömbből meg tudjuk mondani, hogy pontosan hány változóra van szükség: annyira, ahány sikeres eseményre szükség van, azaz ahány $1$-es van a határvonal bal oldalán: tegyük fel, hogy ez a szám $k$!Ekkor a szükséges lépések számát leírhatjuk $k$ darab változó összegeként. Legyen $X_i$ az a változó, ami azon lépések számát írja le, ami ahhoz kell, hogy a bal oldalon $i$ darab $1$-esből $i-1$ darab $1$-est csináljunk (tehát az utolsó lépés volt az egyetlen sikeres és hasznos csere a lépéssorozatban).Ekkor a lépések számát mostmár az $X_k + X_{k-1} + \\cdots{} + X_1$ változók összege fogja leírni, nekünk pedig ennek az összegnek a várható értékét, azaz $E(X_k + X_{k-1} + \\cdots{} + X_1)$-et kell megmondanunk.Itt van szükség arra a nagyon fontos valszám tételre, hogy a várható érték lineáris, azaz\\[E(X_k + X_{k-1} + \\cdots{} + X_1) = E(X_k) + E(X_{k-1}) + \\cdots{} + E(X_1).\\]Ami nagyon meglepő ebben az összefüggésben az az, hogy ez még akkor is igaz, ha az egyes változók egymástól nem függetlenek és vannak is olyan vprog feladatok, ahol ezt a tulajdonságot nagyon erősen kihasználjuk. Ez most nem ilyen, itt a változóink függetlenek lesznek, ezért ez talán kevésbé meglepő, de akit érdekel a téma, például itt olvashat ezzel kapcsolatban: https://brilliant.org/wiki/linearity-of-expectation/. Lehet hozok majd erre építő feladatot is önképzőkörre. :)Ekkor már csak egy $E(X_i)$-t kell megmondanunk. Amennyiben $i$ darab $1$-es van a bal oldalon, akkor a $p_i$ sikeres csere valószínűséget felírhatjuk a kedvező / összes eset darabszám hányadossal a következőképpen:  Mivel $n$ elemű a tömb, az összes eset az, hogy hányféleképpen tudok egy rendezett indexpárt kiválasztani az elemek közül, ez $\\binom{n}{2}$.  A kedvező esetek száma az, hogy hányféleképpen tudok $1$-est választani a határvonal bal oldalán és $0$-ást a jobb oldalán.  Amennyiben $i$ darab $1$-es van bal oldalt, tuti hogy ugyanennyi $0$-ás van jobb oldalt, ezekből akarunk egy párt választani, azaz $i\\cdot{}i = i^2$ a kedvező esetek száma.Tehát\\[p_i = \\frac{i^2}{\\binom{n}{2}}.\\]Ebből pedig következik, hogy a várható értéke egy változónak\\[E(X_i) = \\frac{1}{p_i} = \\frac{\\binom{n}{2}}{i^2}.\\]Az összeg várható értéke pedig\\[E = E(X_k) + E(X_{k-1}) + \\cdots{} + E(X_1) = \\sum\\limits_{i=1}^{k}\\frac{\\binom{n}{2}}{i^2}.\\]Tulajdonképpen ezzel meg is oldottuk a feladatot elméleti szinten, ennek az összegnek a kiszámítását kell leprogramozni.Mielőtt ezt megtennénk, nézzünk meg először egy teljesen másik megoldást:Második megoldási módszer: Markov-lánc elérési idők dinamikus programozássalEgy kis kitérő: a Markov-láncokról (annak, aki még nem ismeri)A Markov-láncok valószínűségszámításban olyan véletlen folyamatokat írnak le, melyek teljesítenek valamilyen fajta memóriamentességi kritériumot. Most ezeknek egy speciális fajtájáról fogok csak beszélni, de az egyszerűség kedvéért csak Markov-láncként fogok hivatkozni rájuk.Képzeljünk el például egy olyan időjárási modellt, ami a következőket állítja:  Ha tegnap sütött a nap, akkor ma $90\\%$ valószínűséggel szintén sütni fog a nap.  Ha tegnap esett az eső, akkor ma $70\\%$ valószínűséggel szintén esni fog az eső.Ezeket az állításokat egy ábrán szemléltethetjük:Ez példa egy nagyon egyszerű Markoc-láncra. A láncnak $2$ lehetséges állapota van, “napos” és “esős”. Az $i.$ napon az $X_i$ valószínűségi változóval jelöljük, hogy milyen idő volt. A fenti állításainkat lefordíthatjuk a valószínűségszámítás nyelvére, mellyel a lánc állapotátmeneti valószínűségeit adhatjuk meg:                              Annak a valószínűsége, hogy az $i.$ napon napos az idő, feltéve hogy az előző, $i-1.$ napon is napos volt: $P(X_i = napos          X_{i-1} = napos) = 0.9$                                                  Annak a valószínűsége, hogy az $i.$ napon esős az idő, feltéve hogy az előző, $i-1.$ napon napos volt: $P(X_i = esős          X_{i-1} = napos) = 0.1$                                                  Annak a valószínűsége, hogy az $i.$ napon napos az idő, feltéve hogy az előző, $i-1.$ napon esős volt: $P(X_i = napos          X_{i-1} = esős) = 0.3$                                                  Annak a valószínűsége, hogy az $i.$ napon esős az idő, feltéve hogy az előző, $i-1.$ napon is esős volt: $P(X_i = esős          X_{i-1} = esős) = 0.7$                    Ehhez szokott tartozni egy állapotátmeneti (általában $\\Pi$-vel jelölt) mátrix:A mátrix oszlopai pedig $1$-re összegződnek, hiszen teljes eseményrendszerről van szó:  Egymást páronként kizárják, hiszen a modellünk szerint egy napon csak egyféle időjárás lehet.  Együtt kiadják a biztos eseményt, hiszen a modellünk szerint minden nap van valamilyen időjárás.A memóriamentességi feltétel (vagy ú.n. Markov-feltétel) itt azt jelenti, hogy az adott napi időjárás csak az azt megelőző nap időjárásától függ, “nem pedig az összes múltbéli nap időjárásától”. Ezt az utóbbi idézőjelbe tett szöveget valszámos nyelven úgy kell megfogalmazni, hogy amennyiben a tegnapi időjárás ismert, úgy a mai nap időjárása független minden korábbi nap időjárásától.Vissza a feladathozFeladatunkban felismerhetünk egy hasonló Markov-láncot. Ennek az állapotai legyenek azok, hogy az adott sorozatban éppen hány darab $1$-es szerepel a határvonal bal oldalán. Tudjuk, hogy ennek a lehetséges értékei $0, \\dots{}, k$, ahol $k$ a kiindulási tömbhöz tartozó érték.Korábban már megadtuk a $p_i$ valószínűségeket, melyek pont ennek a láncnak az átmeneti valószínűségei lesznek:A kérdés pedig most az, hogy mennyi a várható lépések száma, amíg a lánc a $k$ állapotból a $0$ állapotba ér?Ez az úgynevezett “hitting time”, vagy magyarul elérési idő.Általánosan levezethető [1], a következők szerint:[1]: https://mpaldridge.github.io/math2750/S08-hitting-times.htmlJelöljük $\\nu_{j\\leftarrow{}i} = \\nu_{j,i}$-vel azt, hogy ha a Markov-lánc aktuális állapota $i$, akkor várhatóan hány lépés után lesz a lánc állapota először $j$.  Ha $i = j$, akkor $\\nu_{i,i} = 0$.  Egyébként $\\nu_{j,i}$-re pedig kell legalább egy lépés.          Ez az egy lépés az állapot kimenő éleire írt valószínűségekkel fog másik $s$ állapotba lépni.      Ehhez a másik $s$ állapothoz szintén tartozik valamilyen várható elérési idő a célállapot felé.      A várható érték linearitása miatt felírható a követkző “önhivatkozó formula”:                  $S$ jelöli a lehetséges állapotok halmazát.          $p_{s,i}$ jelöli az állapotáteneti mátrix $s$. sorának $i$. oszlopát, vagyis hogy mekkora valószínűséggel lépünk $i$ állapotból $s$ állapotba.                    \\[\\nu_{j,i} = 1 + \\sum\\limits_{s\\in{}S} \\nu_{j,s}p_{s,i}\\]Itt a Teljes várható érték tételére támaszkodtunk.Ez speciálisan a mi Markov-láncunkra egy nagyon szép dinamikus programozós megoldássá alakul át.  Mivel a $0$ állapotot akarjuk elérni, ezért csak az a kérdés melyik állapotból jövünk, jelölje ezt $k$.  Jelölje $dp[k]$ azt, hogy mennyi a várható elérési idő a $k$ állapotból a $0$-ba.  Tudjuk, hogy $k\\neq{}0$ esetén biztosan kell legalább egyet lépni.  Ez a lépés lehet sikertelen ($1-p_k$ valószínűséggel), vagy sikeres ($p_k$ valószínűséggel).  A fenti általános képletet felírva erre a feladatra:\\[dp[k] = 1 + (1-p_k) dp[k] + p_k dp[k-1]\\]  Végül ezt átrendezve:\\[p_k \\cdot{} dp[k] = 1 + p_k \\cdot{} dp[k-1]\\]\\[dp[k] = \\frac{1}{p_k} + dp[k-1]\\]  Továbbá:\\[dp[0] = 0\\]Ebből szépen látszik, hogy\\[dp[k] = \\sum\\limits_{i=1}^{k} \\frac{1}{p_k}\\]Ami pedig pont ugyanaz a képlet, amit a geometriai eloszlásos megoldásból is kihoztunk! :)Megoldás kiírása irreducibilis tört alakbanAz első megoldás esetén a következő összeget kell kiszámoltatni:\\[E = \\sum\\limits_{i=1}^{k}\\frac{\\binom{n}{2}}{i^2} = \\frac{n(n-1)}{2}\\sum\\limits_{i=1}^{k}\\frac{1}{i^2}\\]Hozzuk a szummában szereplő törteket közös nevezőre!Legyen ez a közös nevező $D = \\prod\\limits_{i=1}^{k}i^2$\\[E = \\frac{n(n-1)}{2} \\frac{\\sum\\limits_{i=1}^{k}\\frac{D}{i^2}}{D}  = \\frac{P}{Q}\\]Ez azért jó nekünk, mert ennek a törtnek a számlálója és a nevezője is biztosan egész számok, ezért külön ki tudjuk számolni őket:\\[P = n(n-1) \\sum\\limits_{i=1}^{k}\\frac{D}{i^2}\\]\\[Q = 2D\\]Pythonban pedig a pow függvény 3. paraméterébe beírható egy moduló, így moduló lehet vele a $Q$ inverzét meghatározni a $\\frac{P}{Q}$ számolásához.Forráskód:cases = int(input())   for _ in range(cases):       n = int(input())  a = list(map(int, input().split()))       hatar = 0 # Hol van a határ a végeredmény 0-i és 1-esei között.  for i in range(n):    if a[i] == 0:      hatar += 1          k = 0 # Határ előtti 1-esek száma, ennyit kell elmozgatnunk a határ utánra.  for i in range(hatar):    if a[i] == 1:      k += 1  if k==0:    print(0)    continue  D = 1  for i in range(1, k+1):    D *= i*i  S = 0  for i in range(1, k+1):    S += D / (i * i)  P = n*(n-1) * S  Q = 2 * D  mod = 998244353  QInv = pow(Q, -1, mod)    print(int((P * QInv) % mod))És ez jelen pillanatban time limites lesz. :) (TODO)"
  },
  
  {
    "title": "Google Code Jam 2021 - Qualification Round",
    "url": "/posts/2021-04-16-google-code-jam-qualification-round/",
    "categories": "versenyek",
    "tags": "google, codejam",
    "date": "2021-04-16 13:00:00 +0200",
    





    
    "snippet": "Pár hete zajlott le a 2021-es Google Code Jam Qualification Round-ja! Ennek a fordulónak a hossza 30 óra, így bármelyik időzónában is élünk a világban, bőven van 1 teljes napunk megoldani a feladat...",
    "content": "Pár hete zajlott le a 2021-es Google Code Jam Qualification Round-ja! Ennek a fordulónak a hossza 30 óra, így bármelyik időzónában is élünk a világban, bőven van 1 teljes napunk megoldani a feladatokat. A továbbjutáshoz 30 pontot kell szerezni, ennek az összeszedéséhez a szokásos módon nem volt szükség az összes feladat megoldására.Az idei feladatsor a következő volt:  Reversort (7 pont)  Moons and Umbrellas (5, 11, 1 pont)  Reversort Engineering  (7, 11 pont)  Median Sort (7, 11, 10 pont)  Cheating Detection (11, 20 pont)Nézzük meg, hogy hogyan lehetett továbbjutni a következő fordulóba!1. Feladat: ReversortFeladatkiírásA Reversort egy olyan algoritmus, ami egy listát tud növekvő sorrendbe állítani, a “Reverse” operáció használatával.Ez az operáció a listának egy összefüggő részét tudja megfordítani, a következő pszeudokód alapján:(A tömbök indexelése 1-től kezdődik.)Reversort(L):  for i := 1 to len(L) - 1    j := L[i..]-ben a minimum érték indexe    Reverse(L[i..j])A fenti kód végigiterál a tömbön és minden lépésben az aktuális pozíción lévő számot kicseréli a még hátralévő tömbben lévő minimális számmal, mindezt úgy, hogy a közöttük lévő számokat is fordított sorrendbe teszi, tehát megfordítja ezt az egész listarészt.Látható, hogy az iteráció végén a tömbben lévő számok növekvő sorrendben fognak állni.Ez az algoritmus eléggé pazarló, a feladat az, hogy kiszámoljuk hogy mennyire. A bemeneten kapunk egy listát, össze-vissza sorrendben, nekünk pedig össze kell adni (az erre lefuttatott algoritmusban) iterációnként a megfordított listák hosszait és ezt az összeget kiírni a kimenetre.MegoldásEgyetlen teszthalmaz van, ami rögtön látszik rajta, hogy nagyon kicsi: T=100 db teszteset, legfeljebb N=100 db számmal a listában. Ha a fenti algoritmust megnézzük, nagy vonalakban ~N-szer hajtja végre a ciklust, belül a minimum megtalálása ~N lépés, a string megfordítása szintén ~N lépés, tehát ~2*N^2=2*10^4 lépésben fut. Fontos tudni, hogy 1 mp körülbelül 10^7 ~ 10^8 db utasításnak felel meg programozási versenyeken, tehát bőven 1 mp alatt vagyunk. A teszthalmazra 10 mp time limit van és 1 GB memóriát használhatunk, mindkettőbe bele fogunk férni ha csak lekódoljuk a fenti pszeudokódot.Érdemes tehát ezt a feladatot megcsinálni, mert:  7 pontot ad, ez a 30-ból elég sok.  Csak a megadott pszeudokódot kell egy konkrét programozási nyelvre lefordítani, várhatóan gyorsan elkészülünk.  Azonnal látható az eredményünk (Visible Verdict), biztosan tudhatjuk hogy megkaptuk a 7 pontot.  A feladat szövege írja, hogy egy későbbi feladat ehhez nagyon hasonló, lehet hogy 2 legyet ütünk egy csapásra ha foglalkozunk most ezzel.Nyelvnek a Pythont választottam a tömörsége és a pszeudokódhoz hasonló szintaxisa miatt. Programozási versenyeken C++ és Python között szoktam választani, attól függően hogy mennyire szűk az időkorlát a teszteseteken. Itt most nem volt az, ezért jó választás a Python.A következő kódot adtam be (a kommentek nélkül):n = int(input()) # Input 1. sora: tesztesetek számafor n_i in range(n):  cost = 0  m = int(input()) # Teszteset 1. sora: lista hossza  l = list(map(int, input().split(' '))) # Teszteset 2. sora: maga a lista  # Itt kezdődik a Reversort  for i in range(m-1):    j = l.index(min(l[i:m])) # Legkisebb elem megkeresése a hátralévő tömbben.    cost += j-i+1 # Résztömb hosszának hozzáadása a végleges költséghez.    l[i:j+1] = reversed(l[i:j+1]) # Résztömb megfordítása.  print(f\"Case #{n_i+1}: {cost}\") # Eredmény kiírása megfelelő formátumban.Látszik, hogy a Reversort pszeudokódját szinte csak le kellett fordítani Python nyelvre és készen is volt a feladat. Az indexekkel kellett csak egy kicsit küzdeni, mire kijöttek jól (tanulság: Pythonban minden beépített függvénynél balról zárt, jobbról nyílt az összes intervallum), illetve a list.index és a reversed függvényt eddig nem ismertem, ezekre rá kellett keresni.Ezzel szereztünk 7 pontot, még 23 pontra van szükségünk.2. Feladat: Moons and UmbrellasFeladatkiírásA sztoritól eltekintve annyi a feladat, hogy kapunk egy stringet, ami C, J illetve ? karaktereket tartalmaz, a ? karakterek helyére kell úgy C és J karaktereket írni, hogy a kapott stringben a lehető legkevesebb legyen a CJ és a JC részstringek darabszámának a súlyozott összege. A CJ-k darabszámát X-el, a JC-k darabszámát Y-al súlyozzuk, ezeket a paramétereket szintén az inputon kapjuk meg.MegoldásA három teszthalmazból az 1. (5 pontért) nagyon pici, legfeljebb 10 hosszú lehet a string, itt a max ~2^10 db összes esetet is végig tudnánk próbálgatni. Ha olyan helyzetben lennénk, hogy a többi feladat közül már megoldottunk párat és pont ez az 5 pont hiányzik a 30-ból, akkor itt érdemes ennyit lekódolni és nem foglalkozni a többi tesztesettel.A 2. teszthalmaz (11 pontért) már legfeljebb 1000 hosszú stringeket tartalmaz, a 2^1000 db eset (2^4 = 16 &gt; 10) alulról becsülve 10^250 darab lenne, ami még akkor is nagyon sok ha 1 lépésben végezni tudnánk 1-1 esettel. Itt már nem lehet brute force algoritmust adni, hanem gondolkozni is kell, viszont 11 pontért érdemes lehet foglalkozni vele.A 3. teszthalmaz (1 pontért) azonban nagyon nem szimpatikus. Csak 1 pontot ér, de a súlyok között negatív értékek is megjelenhetnek, amiket teljesen ellentétes módon kell kezelni (maximalizálni kell a darabszámot minimalizálás helyett), a stringek hossza szintén 1000, tehát brute force algoritmust sem adhatunk és mindemellett még Hidden Verdict-es is, tehát nem is fogjuk tudni azonnal, hogy sikerült-e. Ez az a teszteset amivel nem érdemes foglalkozni, csak ha a 2. teszthalmaz megoldása közben eszünkbe jut valami gyors erre is, egyébként csak az időnket vesztegetnénk.Az első két teszthalmazra a következő Python kódot adtam be:n = int(input())for n_i in range(n):  x, y, m = input().split()  x = int(x)  y = int(y)  m = m.replace('?', '')  xc = m.count('CJ')  yc = m.count('JC')  print(f\"Case #{n_i+1}: {x*xc + y*yc}\")Ha minimalizálni szeretnénk a CJ-k és a JC-k darabszámát, akkor tulajdonképpen a váltakozásokat szeretnénk minimalizálni. Ha egyszerűen végigmegyek balról-jobbra a stringen és minden ? helyére beírom a tőle balra lévő karaktert (aki már nem lehet ?, mert az előző lépésben biztosan átírtam), illetve ha ? sorozattal kezdődik a string, akkor azok helyére balról az első nem-? karaktert, akkor pont egy ilyen minimalizált megoldást kapok. Ebben a C-kből és J-kből álló stringben kell megszámolni a CJ és JC részstringeket és kiírni a súlyozott összeget: ez egy jó megoldás lenne.Viszont ennél sokkal egyszerűbb csak törölni a ?-eket, hiszen a fenti módszer csak annyit csinál, hogy a ?-ek helyére “elcsúsztatja” valamelyik oldalról az első nem ? karaktert, tehát új váltakozást nem fog bevezetni, csak a meglévőket húzza össze egymás mellé.Például ezt az input stringet:???JC??C??JCJErre fogja átírni:JJJJCCCCCCJCJDe ebben pont ugyanannyi CJ és JC van, mint a kérdőjelek törlésével kapott stringben:JCCJCJEzt viszont egy kicsit könnyebb programozottan kiszámolni az inputból (m.replace('?', '')).Nyelvnek pedig itt szintén érdemes a Pythont választani, mert tömör és mert 10 mp-ünk van teszthalmazonként, ami bőven elég a fenti program lefuttatására.Ezzel szereztünk összesen 16 pontot, még 7 pontra van szükségünk.3. Feladat: Reversort EngineeringFeladatkiírásEz az a feladat ami ugyanúgy indul mint a Reversort, azonban most felcserélődnek a szerepek: most az inputon kapjuk meg a lista hosszát és a costot és nekünk kell adni egy olyan listát aminek a sorrendezése ennyibe fog kerülni a Reversort használatával (vagy kiírni, hogy IMPOSSIBLE ha ilyet nem lehet).MegoldásAz első teszthalmaznál a lista hossza legfeljebb 7 lehet. Ez azért nagyon kényelmes, mert a 7!=5040 lehetséges sorrendet végig tudjuk próbálgatni egyesével, mindegyiken lefuttatni az 1. feladatra adott megoldásunkat és ahol az ottani cost egyezik az inputon megadottal, azt a sorrendet kiírni. Ha nincs ilyen, akkor pedig azt, hogy IMPOSSIBLE. Ez a teszthalmaz 7 pontot ér, nekünk pont ennyire van szükségünk, ezért ezzel a megoldással tulajdonképpen készen is vagyunk, itt befejezhetjük a versenyt.A második teszthalmaz már nehezebb, itt legfeljebb 100 lehet a lista hossza, 100! esetre már biztosan nem fog a brute force algoritmus időben lefutni. Mivel még volt elég sok idő vissza a versenyből, ezért úgy döntöttem, hogy kíváncsiságból megpróbálom ezt a teszthalmazt is megoldani.A megoldás kulcsa az, hogy visszafele gondolkozunk: kiindulunk a végeredményből, az N hosszú rendezett listából, visszafele iterálunk rajta és lépésenként “visszaforgatunk” benne általunk választott hosszúságú résztömböket, amíg el nem érünk a kiindulási, összekevert listába. Ha úgy választjuk meg a résztömbök hosszait, hogy azoknak az összege pont kiadja a costot, akkor a kapott kiindulási tömb a megoldás lesz. (Meg itt persze menet közben észre kell venni, ha lehetetlen a feladat.)Az első megfigyelés az az, hogy minden lépésben legalább 1 costot el fogunk használni, mivel azt írja a feladat, hogy ha pont az aktuális pozíción van a legkisebb elem, akkor is “megfordítjuk” azt az egyelemű részt. Mivel ez az n-1 db pozíción biztosan fel fog merülni költségként, ezért érdemes ezt már az elején levonni (lekönyvelni), hogy a további számolások során ne történhessen meg az, hogy minden costot elhasználtunk de még nem értünk el a lista elejére.Ennek a következménye, hogy a k hosszú lista megfordításának költsége innentől kezdve k-1 lesz, mert azt az 1-et már lekönyveltük.A következő megfigyelés pedig az, hogy hátulról visszafele adott pozíciókban a következő costokból választhatok:(Itt a tömböt 0…n-1 -el indexeljük, a Reversort a tömb utolsó elemére nem fut le, ezért visszafele az n-2. indexnél kezdünk.)  n-2. index: 0, ha az n-2. elemet helyben forgatom és 1, ha az n-2. és n-1. elemeket megcserélem.  n-3. index: 0,1,2, hasonlóan.  n-4. index: 0,1,2,3, hasonlóan.…            index: 0,1,…,n-1.      A feladat tehát az, hogy a megadott costot rakjuk össze összegként úgy, hogy a fenti lépésekben mindenhol 1 számot választhatunk. Mivel minden lépésben tudunk bármilyen kicsi számot választani, ezért jó stratégia minden iterációban a maximumot választani, hogy minnél jobban csökkenjen a cost, kivéve ha azzal túllőnénk. Amennyiben a listában szereplő maximális érték már több, mint a hátralévő cost, akkor a cost-al egyenlő értéket választjuk ki a listából (ilyen biztosan van), a hátralévő iterációkban pedig mindig 0-t.Ezt az algoritmust implementáltam Pythonban:# Input 1. sora: tesztesetek száma.z = int(input())for z_i in range(z):  # Teszteset 1. sora: elvárt lista hossza, elvárt cost értéke.  n, c = map(int, input().split(' '))    # Itt gyorsan kizárjuk a lehetetlen eseteket:    # Tudjuk, hogy a minimális cost n-1, ha ennél kevesebb a cél,  # akkor az lehetetlen.  if c &lt; n-1:    print(f\"Case #{z_i+1}: IMPOSSIBLE\")    continue  # A maximális cost minden lépésben a legnagyobb számot választani,  # ami az N,...,2 számok összege (1 nincs, mert az utolsó elemre  # nem fut le a Reversort).  if n*(n+1)/2-1 &lt; c:    print(f\"Case #{z_i+1}: IMPOSSIBLE\")    continue  # A teszthalmazok leírásában benne van, hogy 2&lt;n, ez itt felesleges,  # csak nem vettem észre.  if n == 1:    print(f\"Case #{z_i+1}: 1\")    continue  # Ezen a ponton biztosan van megoldás:  # Lekönyveljük a biztos n-1 költséget.  c -= (n-1)    # Itt először előre kiszámolom a costokat (ez egyébként nem szükséges,  # menet közben is lehetne):    # Ebben fogom tárolni, hogy az adott kezdőindexhez hol van a forgatandó  # résztömb vége.  torev = list(range(n))  # Itt előrefele megyek, majd a forgatásos ciklusban szükséges csak  # visszafele menni.  for i in range(n-1):    # Itt kiszámolom, hogy ebben a körben mennyi costot tudok elkönyvelni    # (vagy a leghosszabb lehetséges résztömb hosszát, vagy ha az túl sok,    # akkor a teljes hátralévő costot el tudom könyvelni).    j = min(n-1-i, c)    # Elmentem hol van a forgatott résztömb vége. Itt a +1/-1-eken kell    # egy kicsit agyalni, de így jön ki jól.    torev[i] = i + j    # Csökkentem a costot az ebben az iterációban elkönyvelt értékkel.    c -= j      # Itt pedig visszafele lejátszom a fent kiszámolt forgatásokat és  # legenerálom a kiindulási tömböt:    # Kiindulunk az n hosszú rendezett listából.  l = list(range(1,n+1))  # i=n-2...0  for i in range(n-2,-1,-1):    # Forgatandó lista vége.    j = torev[i]    # Még több +1/-1 fejfájás.    l[i:j+1] = reversed(l[i:j+1])      # Eredmény kiírása:    st = \" \".join(map(str, l))  print(f\"Case #{z_i+1}: {st}\")Itt sokféleképpen lehetne számolni, tulajdonképpen az n-1 előre lekönyvelése sem szükséges, menet közben is észre lehetne venni ha kifogytunk a megengedett costból. Ezen a kódon még sokat lehetne egyszerűsíteni. :)Ezzel szereztünk összesen 18 pontot, a többi feladattal együtt ez 41 pont. Minden teszthalmaz, amit beküldtünk Visible Verdict-es volt, ezért biztosak lehetünk benne, hogy be is jutottunk a következő fordulóba!A forráskódok (kommentezés nélkül) megtalálhatóak a versenyprogramozas/solutions reposiositoryban."
  }
  
]

